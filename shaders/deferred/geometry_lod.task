#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_ARB_shader_draw_parameters : require
#extension GL_EXT_debug_printf : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

#define MESHLETS_PER_TASK 32
#define MAX_MESHLETS_PER_DRAW 4096

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 2) uniform GlobalUniform {
    mat4 view;
    mat4 view_proj;
    vec4 frustum_planes[6]; // Frustum planes in view space
    vec3 camera_position;
} global_uniform;

#include "mesh_shading/mesh.h"

layout (std430, binding = 3) readonly buffer MeshDrawBuffer
{
    MeshLoDDraw mesh_draws[];
};

layout(std430, binding = 4) readonly buffer MeshInstanceDrawBuffer
{
    MeshInstanceDraw instances[];
};

layout(std430, binding = 5) readonly buffer MeshDrawCommandBuffer
{
    MeshDrawCommand commands[];
};

layout(std430, binding = 8) buffer ClusterGroupBuffer {
    ClusterGroup cluster_groups[];
};

layout(std430, binding = 10) buffer ClusterBuffer {
    Cluster clusters[];
};

layout(std430, binding = 11) buffer PageStateBuffer {
    uint8_t page_state[];
};

layout(std430, binding = 12) buffer ValidDataSizeBuffer {
    uint valid_data_size;
};

layout(std430, binding = 13) buffer RecheckCountsBuffer {
    uint recheck_count;
};

layout(std430, binding = 14) writeonly buffer RecheckListBuffer {
    RecheckCluster recheck_clusters[];
};

layout(std430, binding = 15) writeonly buffer OcclusionCommandBuffer {
    OcclusionCommand occlusion_commands[];
};

layout(std430, binding = 16) buffer OcclusionCountsBuffer {
    uint occlusion_count;
};

layout(set = 0, binding = 17) uniform sampler2D uHZB;

layout(set = 0, binding = 18) uniform HZBInfo {
    uint  width;
    uint  height;
    uint  mip_count;
    uint  is_first_frame;
    float depth_bias;
} hzb_info;

layout(push_constant) uniform LOD {
    float threshold;
} lod;

// Task output payload
struct TaskData {
    uint clusterIndices[32];
    uint instance_index;
};

taskPayloadSharedEXT TaskData taskData;

// Cone culling function
bool coneCull(vec3 center, float radius, vec3 cone_axis, float cone_cutoff, vec3 camera_position) {
    vec3 to_center = center - camera_position;
    float dist = length(to_center);
    return dot(to_center, cone_axis) >= cone_cutoff * dist + radius;
}

// Frustum culling function
bool frustumCull(vec3 center_view_space, float radius) {
    for (int i = 0; i < 6; ++i) {
        if (dot(global_uniform.frustum_planes[i], vec4(center_view_space, 1.0)) < -radius) {
            return false;
        }
    }
    return true;
}

// const float lod_error_threshold = 1.0f;
const float screen_height = 1080.0f;
const float test_fov = 3.14159265359f / 2.0f;
const float cot_half_fov = 1.0f / tan(test_fov / 2.0f);

vec4 transformSphere(vec4 sphere, mat4 transform) {
    vec4 h_center = vec4(sphere.xyz, 1.0f);
    h_center = transform * h_center;
    const vec3 center = h_center.xyz / h_center.w;
    if (isinf(sphere.w))
    {
        // debugPrintfEXT("%f", length((transform * vec4(sphere.w, 0, 0, 0)).xyz));
        return vec4(center, sphere.w);
    }
    return vec4(center, length((transform * vec4(sphere.w, 0, 0, 0)).xyz));
}

float projectErrorToScreen(vec4 transformed_sphere) {
    if (isinf(transformed_sphere.w)) {
        return transformed_sphere.w;
    }
    const float d2 = dot(transformed_sphere.xyz, transformed_sphere.xyz);
    const float r = transformed_sphere.w;
    if (d2 <= r * r) {
		// debugPrintfEXT("d2 <= r * r %f %f", d2, r);
		return 1.0f / 0.0f; // return inf
	}
    return screen_height / 2.0f * cot_half_fov * r / sqrt(d2 - r * r);
}

bool lodCull(ClusterGroup cluster_group, Cluster cluster, mat4 modelview) {
    vec4 projected_bounds = vec4(cluster.lod_bounding_sphere.xyz, max(cluster.cluster_error, 10e-10f));
    projected_bounds = transformSphere(projected_bounds, modelview);

    vec4 parent_projected_bounds = vec4(cluster_group.parent_bounding_sphere.xyz, max(cluster_group.parent_error, 10e-10f));
    parent_projected_bounds = transformSphere(parent_projected_bounds, modelview);

    const float cluster_error = projectErrorToScreen(projected_bounds);
    const float parent_error = projectErrorToScreen(parent_projected_bounds);

    const bool render = cluster_error <= lod.threshold && parent_error > lod.threshold;
    
    if (render)
	{
        debugPrintfEXT("render LOD %d, cluster_error: %f, parent_error: %f, cluster error: %f, parent error: %f, lod threshold: %f\n", cluster_group.lod, cluster.cluster_error, cluster_group.parent_error, cluster_error, parent_error, lod.threshold);
	}
    else
    {
        debugPrintfEXT("not LOD %d, cluster_error: %f, parent_error: %f, cluster Error: %f, parent error: %f, lod_threshold: %f\n", cluster_group.lod, cluster.cluster_error, cluster_group.parent_error, cluster_error, parent_error, lod.threshold);
    }
    return render;
}

struct ScreenPos { vec2 uv; float device_depth; bool valid; };

ScreenPos projectToScreen(vec3 world_pos)
{
    vec4 clip = global_uniform.view_proj * vec4(world_pos, 1.0);
    if (clip.w <= 0.0) {
        return ScreenPos(vec2(0), 0.0, false);
    }
    vec3 ndc = clip.xyz / clip.w;           // [-1,1]

    // debugPrintfEXT("ndc: (%f, %f, %f)", ndc.x, ndc.y, ndc.z);

    vec2 uv  = ndc.xy * 0.5 + 0.5;          // [0,1]
    // float device_depth = ndc.z * 0.5 + 0.5;
    float device_depth = ndc.z;
    return ScreenPos(uv, device_depth, true);
}

uint chooseHZBMip(vec2 uv_min, vec2 uv_max)
{
    vec2 px_min = uv_min * vec2(hzb_info.width, hzb_info.height);
    vec2 px_max = uv_max * vec2(hzb_info.width, hzb_info.height);
    vec2 rect_px = max(px_max - px_min, vec2(1.0)); // avoid 0
    float max_dim = max(max(rect_px.x, rect_px.y), 1.0);
    int mip = int(floor(log2(max_dim)));
    mip = clamp(mip, 0, int(hzb_info.mip_count) - 1);
    return uint(mip);
}

bool occludedByHZB_MinPyramid(vec2 uv_min, vec2 uv_max, float cluster_near_depth)
{
    uv_min = clamp(uv_min, vec2(0), vec2(1));
    uv_max = clamp(uv_max, vec2(0), vec2(1));
    if (uv_max.x <= uv_min.x || uv_max.y <= uv_min.y) return false;

    // vec2 rect_px = (uv_max - uv_min) * vec2(hzb_info.width, hzb_info.height);
    uint mip = chooseHZBMip(uv_min, uv_max);

    float d_c = textureLod(uHZB, 0.5 * (uv_min + uv_max), float(mip)).r;
    float d0  = textureLod(uHZB, uv_min,                  float(mip)).r;
    float d1  = textureLod(uHZB, vec2(uv_max.x, uv_min.y), float(mip)).r;
    float d2  = textureLod(uHZB, vec2(uv_min.x, uv_max.y), float(mip)).r;
    float d3  = textureLod(uHZB, uv_max,                  float(mip)).r;

    float hzb_min = min(d_c, min(min(d0, d1), min(d2, d3)));

    return hzb_min >= cluster_near_depth + hzb_info.depth_bias;
}

bool occludedByHZB_DebugMip0(vec2 uv_min, vec2 uv_max, float cluster_near_depth)
{
    uv_min = clamp(uv_min, vec2(0), vec2(1));
    uv_max = clamp(uv_max, vec2(0), vec2(1));
    if (uv_max.x <= uv_min.x || uv_max.y <= uv_min.y) return false;

    // 转换成像素坐标（基于 mip 0 尺寸）
    ivec2 texSize = textureSize(uHZB, 0);  
    ivec2 px_min = ivec2(floor(uv_min * vec2(texSize)));
    ivec2 px_max = ivec2(ceil (uv_max * vec2(texSize)));

    float hzb_min = 1.0; // 深度最大值（NDC 深度范围 [0,1]）

    // 遍历所有像素，取最小深度
    for (int y = px_min.y; y <= px_max.y; ++y)
    {
        for (int x = px_min.x; x <= px_max.x; ++x)
        {
            float d = texelFetch(uHZB, ivec2(x, y), 0).r;
            hzb_min = min(hzb_min, d);
        }
    }

    return hzb_min >= cluster_near_depth + hzb_info.depth_bias;
}


bool makeScreenRectAndNearDepth(vec3 bbmin, vec3 bbmax, out vec2 uv_min, out vec2 uv_max, out float near_depth)
{
    vec3 bbsize = bbmax - bbmin;
    const int CORNER_COUNT = 8;
    vec3 corners[CORNER_COUNT] = 
    {
        bbmin, 
        bbmin + vec3(bbsize.x, 0.f, 0.f),
        bbmin + vec3(0.f, bbsize.y, 0.f),
        bbmin + vec3(0.f, 0.f, bbsize.z),
        bbmin + vec3(bbsize.xy, 0.f),
        bbmin + vec3(0.f, bbsize.yz),
        bbmin + vec3(bbsize.x, 0.f, bbsize.z), 
        bbmax
     };
    
    uv_min = vec2(1.0);
    uv_max = vec2(0.0);
    near_depth = 0.0f;
    for (int i = 0; i < CORNER_COUNT; i++)
    {
        ScreenPos s = projectToScreen(corners[i]);
        if (s.valid)
        {
            uv_min = min(uv_min, s.uv);
            uv_max = max(uv_max, s.uv);
            near_depth = max(near_depth, s.device_depth);
        }
        else
        {
            return false;
        }
    }

    if (uv_max.x <= uv_min.x || uv_max.y <= uv_min.y) return false;

    vec2 pad = 1.0 / vec2(hzb_info.width, hzb_info.height) * 2.0; // pad by 2px
    uv_min = uv_min - pad;
    uv_max = uv_max + pad;

    return true;
}

void main()
{   
    uint command_index = gl_DrawID;
    uint instance_index = commands[command_index].instance_index;
    MeshInstanceDraw instance = instances[instance_index];
    mat4 model = instance.model;

    // debugPrintfEXT("instance index: %d", instance_index);

	uint ti = gl_LocalInvocationID.x;
    uint mgi = gl_WorkGroupID.x;

    uint base_cluster_index = mesh_draws[instance.mesh_draw_index].cluster_offset;

    uint mi = mgi * 32 + ti;

    if (mi >= mesh_draws[instance.mesh_draw_index].cluster_count)
        return;

    // debugPrintfEXT("cluster index: %d\n", base_cluster_index + mi);

    uint cluster_index = base_cluster_index + mi;

    Cluster cluster = clusters[cluster_index];

    // Transform bounding sphere to world space
    vec4 world_center = model * vec4(cluster.bounding_sphere.xyz, 1.0);
    float scale = length(model[0]); // Assuming uniform scaling
    float radius = cluster.bounding_sphere.w * scale * 1.1; // Slightly inflate the radius

    // Transform center to view space for frustum culling
    vec3 center_view_space = (global_uniform.view * world_center).xyz;

    // Perform frustum culling
    bool frustum_visible = frustumCull(center_view_space, radius);

    // Perform cone culling
    vec3 cone_axis_world = normalize(mat3(model) * cluster.cone_axis);
    float cone_cutoff = cluster.cone_cutoff;
    bool cone_cull_result = coneCull(world_center.xyz, radius, cone_axis_world, cone_cutoff, global_uniform.camera_position);

    ClusterGroup cluster_group = cluster_groups[cluster.cluster_group_index];

#ifdef USE_LOD
    bool lod_check = lodCull(cluster_group, cluster, global_uniform.view * model);
    // bool lod_check = cluster_group.lod == 1;
#else
    bool lod_check = cluster_group.lod == 0;
#endif

    // Determine if the meshlet should be rendered
    bool accept = frustum_visible && !cone_cull_result && lod_check;
    // bool accept = lod_check;

    if (accept) {
        page_state[cluster_group.page_index] |= uint8_t(0x1u);
    }

    bool page_loaded = (page_state[cluster_group.page_index] & 0x2u) != 0u;

    if (!page_loaded) {
        accept = false;
    }

#ifdef USE_OCCLUSION
    if (accept && hzb_info.is_first_frame == 0) {
        vec2 uv_min, uv_max;
        float near_depth;

        vec4 model_bbmin = model * vec4(cluster.bbmin, 1.0);
        vec4 model_bbmax = model * vec4(cluster.bbmax, 1.0);
        // vec4 model_bbmin = model * vec4(cluster_group.bbmin, 1.0);
        // vec4 model_bbmax = model * vec4(cluster_group.bbmax, 1.0);
        if (makeScreenRectAndNearDepth(model_bbmin.xyz, model_bbmax.xyz, uv_min, uv_max, near_depth)) {
            bool occl = occludedByHZB_MinPyramid(uv_min, uv_max, near_depth);
            if (occl) {
                uint idx = atomicAdd(recheck_count, 1); 
                recheck_clusters[idx].cluster_index = mi;
                recheck_clusters[idx].instance_index = instance_index;

                uint draw_index = idx / MAX_MESHLETS_PER_DRAW;

                // debugPrintfEXT("idx: %d, draw_index: %d, occlusion_count: %d, MAX_MESHLETS_PER_DRAW: %d", idx, draw_index, occlusion_count, MAX_MESHLETS_PER_DRAW);

                atomicMax(occlusion_count, draw_index + 1);
                if (idx % MAX_MESHLETS_PER_DRAW == 0)
                {
                    occlusion_commands[draw_index].group_count_x = 1;
                }
                atomicMax(occlusion_commands[draw_index].group_count_x,
          (idx % MAX_MESHLETS_PER_DRAW + MESHLETS_PER_TASK) / MESHLETS_PER_TASK);
                
                // occlusion_commands[draw_idex].group_count_x = (idx % MAX_MESHLETS_PER_DRAW + MESHLETS_PER_TASK) / MESHLETS_PER_TASK;

                occlusion_commands[draw_index].group_count_y = 1;
                occlusion_commands[draw_index].group_count_z = 1;
                accept = false;
            }
            else {
                cluster.occlusion = 0;
            }
        }
        // makeScreenRect 失败时，保守起见维持 accept（也可直接 false，看你策略）
    }
#endif

    if (!accept)
    {
        // debugPrintfEXT("not");
    }

    // Use subgroup operations for efficiency
    uvec4 ballot = subgroupBallot(accept);
    uint index = subgroupBallotExclusiveBitCount(ballot);

    if (accept)
    {
        taskData.clusterIndices[index] = mi;
        // debugPrintfEXT("accept");
    }
    taskData.instance_index = instance_index;

    uint count = subgroupBallotBitCount(ballot);

    // Emit mesh tasks if any meshlets are visible
    if (gl_LocalInvocationID.x == 0 && count > 0) {
        EmitMeshTasksEXT(count, 1, 1);
    }
}