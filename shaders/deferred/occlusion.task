#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_ARB_shader_draw_parameters : require
#extension GL_EXT_debug_printf : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

#define MAX_MESHLETS_PER_DRAW 4096

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 2) uniform GlobalUniform {
    mat4 view;
    mat4 view_proj;
    vec4 frustum_planes[6]; // Frustum planes in view space
    vec3 camera_position;
} global_uniform;

#include "mesh_shading/mesh.h"

layout (std430, binding = 3) readonly buffer MeshDrawBuffer
{
    MeshLoDDraw mesh_draws[];
};

layout(std430, binding = 4) readonly buffer MeshInstanceDrawBuffer
{
    MeshInstanceDraw instances[];
};

layout(std430, binding = 7) buffer ClusterBuffer {
    Cluster clusters[];
};

layout(std430, binding = 9) readonly buffer RecheckListBuffer {
    RecheckCluster recheck_clusters[];
};

layout(std430, binding = 10) readonly buffer RecheckCountsBuffer {
    uint recheck_count;
};

layout(set = 0, binding = 11) uniform sampler2D uHZB;

layout(set = 0, binding = 12) uniform HZBInfo {
    uint  width;
    uint  height;
    uint  mip_count;
    uint  is_first_frame;
    float depth_bias;
} hzb_info;

// Task output payload
struct TaskData {
    uint clusterIndices[32];
    uint instance_index;
};

taskPayloadSharedEXT TaskData taskData;

struct ScreenPos { vec2 uv; float device_depth; bool valid; };

ScreenPos projectToScreen(vec3 world_pos)
{
    vec4 clip = global_uniform.view_proj * vec4(world_pos, 1.0);
    if (clip.w <= 0.0) {
        return ScreenPos(vec2(0), 0.0, false);
    }
    vec3 ndc = clip.xyz / clip.w;           // [-1,1]

    // debugPrintfEXT("ndc: (%f, %f, %f)", ndc.x, ndc.y, ndc.z);

    vec2 uv  = ndc.xy * 0.5 + 0.5;          // [0,1]
    // float device_depth = ndc.z * 0.5 + 0.5;
    float device_depth = ndc.z;
    return ScreenPos(uv, device_depth, true);
}

uint chooseHZBMip(vec2 uv_min, vec2 uv_max)
{
    vec2 pos_min = uv_min * vec2(hzb_info.width, hzb_info.height);
    vec2 pos_max = uv_max * vec2(hzb_info.width, hzb_info.height);
    vec2 rect_px = pos_max - pos_min;

    // debugPrintfEXT("pos_min: (%f, %f), pos_max: (%f, %f)", pos_min.x, pos_min.y, pos_max.x, pos_max.y);

    float max_dim = max(rect_px.x, rect_px.y);
    uint mip = uint(ceil(log2(max_dim)));

    // debugPrintfEXT("rect_px: (%f, %f), mip: %d", rect_px.x, rect_px.y, mip);

    uvec2 dim = (uvec2(pos_max) >> mip) - (uvec2(pos_min) >> mip);

    uvec2 temp = uvec2(pos_min);
    // debugPrintfEXT("temp: (%d, %d)", temp.x, temp.y);

    uint use_lower = uint(step(dim.x, 2.f) * step(dim.y, 2.f));
    mip = use_lower * max(0, mip - 1) + (1 - use_lower) * mip;

    // debugPrintfEXT("dim: (%d, %d), user_lower: %d, mip: %d", dim.x, dim.y, use_lower, mip);

    return mip;
}

bool occludedByHZB_MinPyramid(vec2 uv_min, vec2 uv_max, float cluster_near_depth)
{
    uv_min = clamp(uv_min, vec2(0), vec2(1));
    uv_max = clamp(uv_max, vec2(0), vec2(1));
    if (uv_max.x <= uv_min.x || uv_max.y <= uv_min.y) return false;

    // vec2 rect_px = (uv_max - uv_min) * vec2(hzb_info.width, hzb_info.height);
    uint mip = chooseHZBMip(uv_min, uv_max);

    float d_c = textureLod(uHZB, 0.5 * (uv_min + uv_max), float(mip)).r;
    float d0  = textureLod(uHZB, uv_min,                  float(mip)).r;
    float d1  = textureLod(uHZB, vec2(uv_max.x, uv_min.y), float(mip)).r;
    float d2  = textureLod(uHZB, vec2(uv_min.x, uv_max.y), float(mip)).r;
    float d3  = textureLod(uHZB, uv_max,                  float(mip)).r;

    float hzb_min = min(d_c, min(min(d0, d1), min(d2, d3)));

    // debugPrintfEXT("mip: %d, uv_min: (%f, %f), uv_max: (%f, %f), rect_px: (%f, %f), hzb_min: %f, cluster_near_depth: %f", mip, uv_min.x, uv_min.y, uv_max.x, uv_max.y, rect_px.x, rect_px.y, hzb_min, cluster_near_depth);

    return hzb_min >= cluster_near_depth + hzb_info.depth_bias;
}

bool makeScreenRectAndNearDepth(vec3 bbmin, vec3 bbmax, out vec2 uv_min, out vec2 uv_max, out float near_depth)
{
    vec3 bbsize = bbmax - bbmin;
    const int CORNER_COUNT = 8;
    vec3 corners[CORNER_COUNT] = 
    {
        bbmin, 
        bbmin + vec3(bbsize.x, 0.f, 0.f),
        bbmin + vec3(0.f, bbsize.y, 0.f),
        bbmin + vec3(0.f, 0.f, bbsize.z),
        bbmin + vec3(bbsize.xy, 0.f),
        bbmin + vec3(0.f, bbsize.yz),
        bbmin + vec3(bbsize.x, 0.f, bbsize.z), 
        bbmax
     };
    
    uv_min = vec2(1.0);
    uv_max = vec2(0.0);
    near_depth = 0.0f;
    for (int i = 0; i < CORNER_COUNT; i++)
    {
        ScreenPos s = projectToScreen(corners[i]);
        if (s.valid)
        {
            uv_min = min(uv_min, s.uv);
            uv_max = max(uv_max, s.uv);
            near_depth = max(near_depth, s.device_depth);
        }
    }

    if (uv_max.x <= uv_min.x || uv_max.y <= uv_min.y) return false;

    vec2 pad = 1.0 / vec2(hzb_info.width, hzb_info.height) * 2.0; // pad by 2px
    uv_min = uv_min - pad;
    uv_max = uv_max + pad;

    return true;
}

void main()
{
    uint command_index = gl_DrawID;
    uint base_recheck_index = command_index * MAX_MESHLETS_PER_DRAW;

    // debugPrintfEXT("first cluster_index: %d, instance_index: %d", recheck_clusters[0].cluster_index, recheck_clusters[0].instance_index);

	uint ti = gl_LocalInvocationID.x;
    uint mgi = gl_WorkGroupID.x;
    uint mi = mgi * 32 + ti;
    uint recheck_index = base_recheck_index + mi;

    if (recheck_index > recheck_count) {
        return;
    }

    uint instance_index = recheck_clusters[recheck_index].instance_index;
    MeshInstanceDraw instance = instances[instance_index];
    mat4 model = instance.model;

    uint cluster_offset = mesh_draws[instance.mesh_draw_index].cluster_offset;
    uint cluster_index = cluster_offset + recheck_clusters[recheck_index].cluster_index;
    Cluster cluster = clusters[cluster_index];

    // debugPrintfEXT("recheck_index: %d, instance_index: %d, cluster_index: %d", recheck_index, instance_index, cluster_index);

    bool accept = true;
#ifdef USE_OCCLUSION
    if (hzb_info.is_first_frame == 0) {
        vec2 uv_min, uv_max;
        float near_depth;

        vec4 model_bbmin = model * vec4(cluster.bbmin, 1.0);
        vec4 model_bbmax = model * vec4(cluster.bbmax, 1.0);
        if (makeScreenRectAndNearDepth(model_bbmin.xyz, model_bbmax.xyz, uv_min, uv_max, near_depth)) {
            bool occl = occludedByHZB_MinPyramid(uv_min, uv_max, near_depth);
            if (occl) {
                if (cluster.occlusion == 1)
                {
                     accept = false;
                }
                cluster.occlusion = 1;
                // accept = true;
            }
            else {
                cluster.occlusion = 0;
            }
        }
    }
#endif

    // Use subgroup operations for efficiency
    uvec4 ballot = subgroupBallot(accept);
    uint index = subgroupBallotExclusiveBitCount(ballot);

    if (accept)
    {
        taskData.clusterIndices[index] = recheck_clusters[mi].cluster_index;
    }
    taskData.instance_index = instance_index;

    uint count = subgroupBallotBitCount(ballot);

    // Emit mesh tasks if any meshlets are visible
    if (gl_LocalInvocationID.x == 0 && count > 0) {
        EmitMeshTasksEXT(count, 1, 1);
    }
}