#version 450

#include "mesh_shading/mesh.h"

layout(set = 0, binding = 1) readonly buffer MeshletBuffer
{
    Meshlet meshlets[];
};

layout(set = 0, binding = 2) readonly buffer MeshDrawBuffer
{
    MeshDraw mesh_draws[];
};

layout(set = 0, binding = 3) readonly buffer MeshInstanceDrawBuffer
{
    MeshInstanceDraw instances[];
};

layout(set = 0, binding = 4) buffer VisibleMeshInstances
{
    uint visible_meshlet_indices[];
};

layout(set = 0, binding = 5) buffer MeshDrawCommandBuffer
{
    MeshDrawCommand commands[];
};

layout(std430, binding = 7) buffer CounterBuffer {
    uint total_visible_meshlet_count;
    uint draw_count;
};


layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint instance_index = gl_GlobalInvocationID.x;
    if(instance_index >= instances.length())
        return;

    // ??
    uint local_meshlet_index = gl_LocalInvocationID.x;

    MeshInstanceDraw instance = instances[instance_index];
    MeshDraw mesh_draw = mesh_draws[instance.mesh_draw_index];

    if (local_meshlet_index >= mesh_draw.meshlet_count)
        return;

    uint global_meshlet_index = mesh_draw.meshlet_offset + local_meshlet_index;
    Meshlet meshlet = meshlets[global_meshlet_index];

    // todo test if meshlet is visible

    uint draw_index = atomicAdd(draw_count, 1);
    

    barrier();
    memoryBarrier();

    if(gl_LocalInvocationID.x == 0)
    {
        const uint MESHLETS_PER_TASK = 32;

        uint task_count = (mesh_draw.meshlet_count + MESHLETS_PER_TASK - 1) / MESHLETS_PER_TASK;

        commands[draw_index].group_count_x = task_count;
        commands[draw_index].group_count_y = 1;
        commands[draw_index].group_count_z = 1;
    }
}