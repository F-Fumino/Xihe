#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform sampler2D in_tex;
layout(rgba16f, set = 0, binding = 1) writeonly uniform image2D out_tex;

// Common parameters for all bloom passes
layout(set = 0, binding = 2) uniform CommonUniforms {
    uvec2 resolution;           
    vec2 inv_resolution;        
    vec2 inv_input_resolution;  
} common_uniform;

// Extract pass specific parameters
layout(push_constant) uniform Registers {
    float threshold;           
    float soft_threshold;      
    float intensity;          
    float saturation;         
} registers;

// Calculate luminance from RGB
float get_luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// Adjust color saturation
vec3 adjust_saturation(vec3 color, float adjustment) {
    float luminance = get_luminance(color);
    return mix(vec3(luminance), color, adjustment);
}

void main() {
    // Check if within output resolution bounds
    if (any(greaterThanEqual(gl_GlobalInvocationID.xy, common_uniform.resolution))) {
        return;
    }

    // Calculate input UV with proper scaling
    vec2 uv = (vec2(gl_GlobalInvocationID.xy) + 0.5) * common_uniform.inv_resolution;
    
    // Sample input texture
    vec3 rgb = textureLod(in_tex, uv, 0.0).rgb;
    
    // Calculate luminance and apply threshold with smooth transition
    float luminance = get_luminance(rgb);
    float brightness = smoothstep(registers.threshold, 
                                registers.threshold + registers.soft_threshold, 
                                luminance);
    
    // Extract bright areas
    vec3 bright_color = rgb * brightness;
    
    // Apply saturation adjustment
    bright_color = adjust_saturation(bright_color, registers.saturation);
    
    // Apply intensity
    bright_color *= registers.intensity;
    
    // Store result
    imageStore(out_tex, ivec2(gl_GlobalInvocationID.xy), vec4(bright_color, 1.0));
}