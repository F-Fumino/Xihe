#version 450
layout(local_size_x = 16, local_size_y = 1) in;

layout(binding = 0, rgba16f) uniform readonly image2D inputImage;
layout(binding = 1, rgba16f) uniform writeonly image2D outputImage;

layout(push_constant) uniform PushConstants {
    float innerWeight;
    float outerWeight;
    int isVertical;
} pc;

shared vec3 sharedPixels[40];  // 32 + 8 padding

void main() {
    ivec2 sourceSize = imageSize(inputImage);
    uint localID = gl_LocalInvocationID.x;  // 0-15
    
    // 计算基础加载位置
    ivec2 basePos;
    if(pc.isVertical == 1) {
        basePos = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y * 32 - 4);
    } else {
        basePos = ivec2(gl_WorkGroupID.y * 32 - 4, gl_WorkGroupID.x);
    }
    
    // 每个线程负责加载40/16=3个位置（向上取整）
    // 最后一个线程可能少加载一些
    for(int i = 0; i < 3; i++) {
        int loadIndex = int(localID) + i * 16;
        if(loadIndex < 40) {  // 确保不越界
            ivec2 loadPos;
            if(pc.isVertical == 1) {
                loadPos = basePos + ivec2(0, loadIndex);
            } else {
                loadPos = basePos + ivec2(loadIndex, 0);
            }
            
            // 边界检查
            if(loadPos.x >= 0 && loadPos.x < sourceSize.x && 
               loadPos.y >= 0 && loadPos.y < sourceSize.y) {
                sharedPixels[loadIndex] = imageLoad(inputImage, loadPos).rgb;
            } else {
                sharedPixels[loadIndex] = vec3(0.0);
            }
        }
    }
    
    // 等待所有线程完成加载
    barrier();
    memoryBarrierShared();
    
    // 每个线程处理2个输出像素
    for(int i = 0; i < 2; i++) {
        int pixelIndex = int(localID) + i * 16;
        if(pixelIndex < 32) {  // 只处理实际需要的32个像素
            ivec2 outputPos;
            if(pc.isVertical == 1) {
                outputPos = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y * 32 + pixelIndex);
            } else {
                outputPos = ivec2(gl_WorkGroupID.y * 32 + pixelIndex, gl_WorkGroupID.x);
            }
            
            if(outputPos.x < sourceSize.x && outputPos.y < sourceSize.y) {
                // 计算在shared memory中的基础索引（考虑padding）
                int baseIndex = pixelIndex + 4;  // +4 for padding offset
                
                vec3 color = sharedPixels[baseIndex - 4] * pc.outerWeight +
                            sharedPixels[baseIndex - 3] * pc.outerWeight +
                            sharedPixels[baseIndex - 2] * pc.innerWeight +
                            sharedPixels[baseIndex - 1] * pc.innerWeight +
                            sharedPixels[baseIndex    ] * pc.innerWeight +
                            sharedPixels[baseIndex + 1] * pc.innerWeight +
                            sharedPixels[baseIndex + 2] * pc.innerWeight +
                            sharedPixels[baseIndex + 3] * pc.outerWeight +
                            sharedPixels[baseIndex + 4] * pc.outerWeight;
                
                float totalWeight = pc.innerWeight * 5.0 + pc.outerWeight * 4.0;
                color /= totalWeight;
                
                imageStore(outputImage, outputPos, vec4(color, 1.0));
            }
        }
    }
}